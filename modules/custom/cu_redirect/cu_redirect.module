<?php

include_once 'cu_redirect.features.inc';

/**
 * Implements hook_redirect_validate().
 *
 * @param $redirect
 * @param $form
 * @param $form_state
 */
function cu_redirect_redirect_validate($redirect, $form, $form_state) {
  // Set error if user is trying to use the frontpage as the source for a redirect.
  if ($redirect->source == variable_get('site_frontpage', 'node')) {
    form_set_error('cu_redirect', t('The redirect source "@from" cannot be the same path as the homepage.', array('@from' => $redirect->source)));
  }
}

/**
 * Adds a redirect if none exists.
 */
function cu_redirect_add_redirect($source = NULL, $destination = NULL) {
  if ($source == NULL || $destination == NULL) {
    return;
  }
  // Make redirect if none exists.
  if (_cu_redirect_check_existing($source)) {
    _cu_redirect_set_redirect($source, $destination);
  }
}

/**
 * Check for existing redirect.
 */
function _cu_redirect_check_existing($source = NULL) {
  // Get internal path.
  drupal_get_normal_path($source);

  // Check for existing redirect.
  $query = db_select('redirect', 'r');
  $query->addField('r', 'source');
  $query->condition('r.source', $source);
  $redirect = $query->execute()->fetchCol();

  if (empty($redirect)) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Make a redirect.
 */
function _cu_redirect_set_redirect($source = NULL, $destination = NULL) {
  try {
    $redirect = new stdClass();
    redirect_object_prepare($redirect);
    $redirect->source = $source;
    $redirect->redirect = $destination;
    // Always make redirects from UID 1.
    $redirect->uid = 1;
    redirect_save($redirect);
  } catch (Exception $e) {
    watchdog_exception('cu_redirect', $e);
    throw $e;
  }
}

/**
 * Implements hook_cron().
 *
 * Delete any redirects created by UID 1 after 30 days if they haven't been
 * accessed.
 *
 * @return mixed
 * @throws \Exception
 */
function cu_redirect_cron() {

  // If site hasn't launched, don't delete redirects.
  if (variable_get('cu_inventory_status', NULL) != 'launched') {
    return;
  }

  // Get all redirects created by UID 1 that haven't been accessed in 90 days.
  $interval = 7776000;
  $query = db_select('redirect');
  $query->addField('redirect', 'rid');
  $query->condition('uid', 1, '=');
  $query->condition('access', REQUEST_TIME - $interval, '<');
  $query->addTag('redirect_purge');
  $rids = $query->execute()->fetchCol();

  // Delete any redirects that are returned.
  if (count($rids)) {
    // Since this function is in a module file, no include is necessary.
    redirect_delete_multiple($rids);
    watchdog('cu_redirect', format_plural(count($rids), 'Removed 1 inactive redirect from the database.', 'Removed @count inactive redirects from the database.'));
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function cu_redirect_form_redirect_list_form_alter(&$form, &$form_state, $form_id) {
  $form['unaccessed_links'] = array(
    '#type' => 'fieldset',
    '#title' => t('Delete Stale Redirects'),
    '#prefix' => '<div class="container-inline">',
    '#suffix' => '</div>',
    '#weight' => -1,
  );

  $form['unaccessed_links']['text'] = array(
    '#type' => 'markup',
    '#markup' => '<p>Some redirects are never accessed and clutter up this reports page. You can clear those stale redirects here. Redirects are considered stale if they have not been accessed in at least 90 days.</p>',
  );

  $form['unaccessed_links']['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Delete Stale Redirects',
    '#validate' => array('cu_redirect_unaccessed_links_validate'),
    '#submit' => array('cu_redirect_unaccessed_links_submit'),
  );
}

/**
 * Validation handler for clear stale links submit button.
 */
function cu_redirect_unaccessed_links_validate($form, &$form_state) {

}

/**
 * Submit handler for clear stale links submit button.
 */
function cu_redirect_unaccessed_links_submit($form, &$form_state) {

  $query = db_select('redirect');
  $query->addField('redirect', 'rid');
  //$query->condition('uid', 1, '=');
  $query->condition('access', 0, '=');
  $query->addTag('redirect_purge');
  $rids = $query->execute()->fetchCol();

  // Delete any redirects that are returned.
  if (count($rids)) {
    // Since this function is in a module file, no include is necessary.
    redirect_delete_multiple($rids);
    watchdog('cu_redirect', format_plural(count($rids), 'Removed 1 inactive redirect from the database.', 'Removed @count inactive redirects from the database.'));
    drupal_set_message('Redirects that were never accessed have been cleared.');
  }
  else {
    drupal_set_message('There are no redirects that were never accessed. No redirects have been removed.', 'warning');
  }
}

/**
 * Implements hook_redirect_save().
 *
 * @param $redirect
 *   The redirect that is being inserted or updated.
 */
function cu_redirect_redirect_presave($redirect) {
  // If redirect is made from node/add or node/edit page, make UID admin.
  // This is for cleaning up non-user created redirects
  if (strpos(current_path(), 'node') == 0) {
    $redirect->uid = 1;
  }
}


/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Remove 300 redirect option from form.
 */
function cu_redirect_form_redirect_edit_form_alter(&$form, &$form_state, $form_id) {
  if (!empty($form['advanced']['status_code'])) {
    unset($form['advanced']['status_code']['#options'][300]);
  }
}
